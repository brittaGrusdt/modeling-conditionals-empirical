/**
* RSA Literal Listener
* @param {string} utterance
* @return {Distribution}
*/
var literal_listener = cache(function(utterance, thresholds) {
  Infer({method:'enumerate',model: function(){
    var state = sample(globalStore.state_prior)
    // display(state.bn_id + ' utt: ' + utterance)
    condition(meaning(utterance, state["table"], thresholds))
    return state
  }})
}, 10000)

/**
* RSA Literal Listener marginalized to get distribution over tables only
* @param {string} utterance
* @return {Distribution}
*/
var marginal_LL = cache(function(utterance, thresholds){
  // display("enter marginal LL")
  var ll = literal_listener(utterance, thresholds)
  var marginal = marginalize(ll, 'table')
  // display('marginal: ' + marginal.support().length)
  return(marginal)
}, 10000)

/**
* RSA Speaker
* @param {object} state with fields 'table': mapping to Table distribution,
* 'r' mapping to causal relation and 'bn_id' which is a unique id for state
* @param {boolean} displayU for debugging, if true displays utilities of each
* sampled utterance
* @return {Distribution}
*/
var speaker = function(state, displayU){
  let distr = Infer({method:'enumerate', model: function(){
    // var utterance = uniformDraw(globalStore.utterances)
    var utterance = categorical({vs: globalStore.utterances,
                                 ps: globalStore.ps_utts})
    var LL = marginal_LL(utterance, globalStore.thresholds)
    var utility = LL.score(state.table) - cost(utterance)
    if(displayU && utility != -Infinity){
      display(utterance + ": " + utility)
    }
    factor(globalStore.alpha * utility)
    return(utterance)
    }
  });
 return(distr)
}


var speaker0 = function(state, displayU){
  let distr = Infer({method:'enumerate', model: function(){
    var utterance = uniformDraw(globalStore.utterances)
    // all applicable utterances for 'state' are equally likely
    var utility_meaning = meaning(utterance, state["table"], globalStore.thresholds) ? 0 : -Infinity
    var utility = utility_meaning //- cost(utterance)

    if(displayU && utility != -Infinity) { display(utterance + ": " + utility) }

    factor(globalStore.alpha * utility)
    return(utterance)
    }
  });
return(distr)
}


/**
* RSA Pragmatic Listener
* @param {string} utterance
* @return {Distribution}
*/
var listener = function(utterance){
  return Infer({method:'enumerate', model:function(){
                  var state = sample(globalStore.state_prior)
                  var sp = speaker(state, false)
                  observe(sp, utterance)
                  return state
                }})
}

/**
* RSA Literal Listener based on utterance types
* @param {string} utterance
* @return {Distribution}
*/
var literal_listener_by_type = cache(function(utt_type, thresholds) {
  Infer({method:'enumerate',model: function(){
    var state = sample(globalStore.state_prior)
    condition(meaning_by_utt_type(utt_type, state["bn_id"]))
    return state
  }})
}, 10000)

/**
* RSA Literal Listener marginalized to get distribution over tables only
* @param {string} utterance
* @return {Distribution}
*/
var marginal_LL_by_type = cache(function(utt_type, thresholds){
  // display("enter marginal LL")
  var ll = literal_listener_by_type(utt_type, thresholds)
  var marginal = marginalize(ll, 'table')
  // display('marginal: ' + marginal.support().length)
  return(marginal)
}, 10000)


/**
* RSA Speaker for Bayesian inference using utterance types
* @param {object} state with fields 'table': mapping to Table distribution,
* 'r' mapping to causal relation and 'bn_id' which is a unique id for state
* @param {boolean} displayU for debugging, if true displays utilities of each
* sampled utterance
* @return {Distribution}
*/
var speaker_utt_type = function(state, displayU){
  let distr = Infer({method:'enumerate', model: function(){
    //var utterance = uniformDraw(globalStore.utterances)
    var utterance = categorical({vs: globalStore.utterances,
                                 ps: globalStore.ps_utts})
    // distribution over tables only (across all relations)
    var LL = marginal_LL(utterance.utt, globalStore.thresholds)
    var LL_type = marginal_LL_by_type(utterance.type, globalStore.thresholds)
    var utility = LL.score(state.table) == -Infinity ? -Infinity :
      LL_type.score(state.table);
    //var utility = LL.score(state.table) //- cost(utterance.utt)
    if(displayU && utility != -Infinity){
      display(utterance.utt + ": " + utility)
    }
    factor(globalStore.alpha * utility)
    return(utterance)
    }
  });
 return(distr)
}
