var EPSILON =  0.000001;

var exponentialKernel = function(prevVal) {
  var lambda = 1 / prevVal;
  return Exponential({a: lambda});
};

// Functions for zero-one inflated beta distribution //
var sample_zoib_prior = function(){
  var shape1 = sample(Exponential({a: 0.25}), {driftKernel: exponentialKernel})
  var shape2 = sample(Exponential({a: 0.25}), {driftKernel: exponentialKernel})
  var gamma = uniformDrift({a: 0, b:1, width: 0.1})
  var alpha = uniformDrift({a: 0, b:1, width: 0.1})
  return({alpha, gamma, shape1, shape2})
}

var sample_zoib = function(pars){
  var p = bernoulli({p: pars.alpha}) ? bernoulli({p: pars.gamma}) :
    beta({a: pars.shape1, b: pars.shape2});
  return(p)
}

var get_zoib_likelihood = function(p_obs, pars){
  var cat_obs = (p_obs == 0 || p_obs == 1) ? "01" : "Beta";
  var ll_cat = Categorical({vs: ["01", "Beta"],
                            ps: [pars.alpha, 1-pars.alpha]}).score(cat_obs)

  var ll_p_obs = cat_obs == "01" ?
    Bernoulli({p: pars.gamma}).score(p_obs == 1 ? true : false) :
    Beta({a: pars.shape1, b: pars.shape2}).score(p_obs);

  return(ll_cat + ll_p_obs)
}

var get_range_bg = function(p_blue, p_green){
  var min_ac = p_blue + p_green > 1 ? p_blue + p_green - 1 : 0;
  var max_ac = Math.min(p_blue, p_green)
  return({min: min_ac, max: max_ac})
}

// from beta(alpha, beta, a, c) distributed to beta(alpha, beta, 0, 1)
var transform_beta_ac_to_beta_01 = function(y, a, c){
  var x = (y - a) / (c - a)
  return(x)
}

var get_likelihood_bg = function(obs, pars_bg){
  var range_bg = get_range_bg(obs.blue, obs.green)
  var mu = obs.blue * obs.green

  var obs_diff = Math.abs(mu - obs.AC)
  var sign = obs.AC >= mu ? 1 : -1;
  var max_diff = sign > 0 ? range_bg.max - mu : mu - range_bg.min;

  var obs_ratio = Math.round(obs_diff / max_diff * 100, 2) / 100
  var min_is_max = (Math.round(range_bg.min * 100, 2) / 100) == (Math.round(range_bg.max * 100, 2) / 100)

  var val = obs_ratio == 0  ? obs_ratio + EPSILON :
    obs_ratio == 1 ? obs_ratio - EPSILON :
    min_is_max ? EPSILON : obs_ratio;
  var ll_bg = Beta({a: pars_bg.shape1, b: pars_bg.shape2}).score(val)
  return(ll_bg)
}


// var get_likelihood_fn_independent_bg = function(range_bg, mu, ratio){
//   // variance in terms of mu and phi-parameters:
//   // variance = (mu * (1-mu)) / (1+phi)
//   var var_suggested = ratio * (range_bg.max - range_bg.min)
//   var variance = var_suggested < mu * (1-mu) ?
//     var_suggested : mu * (1-mu) - EPSILON;
//
//   var phi = (mu * (1-mu) - variance) / variance
//   //display("mu: " + mu + " phi: " + phi + " variance: " + variance)
//
//   // mu = shape1 / (shape1 + shape2) = shape1 / phi
//   // phi = shape1 + shape2
//   // rearrange so that shape1 and shape2 are given in terms of mu and phi
//   var shape1 = mu * phi
//   var shape2 = -mu * phi + phi
//
//   return(Beta({a: shape1, b: shape2}))
// }

// var get_likelihood_independent_bg = function(p_blue, p_green, ratio, obs_bg){
//   var range_bg = get_range_bg(p_blue, p_green)
//   // P(b,g)~P(b)*P(g) when B,G independent
//   var mu = p_blue * p_green
//
//   var min_is_max = (Math.round(range_bg.min * 100, 2) / 100) == (Math.round(range_bg.max * 100, 2) / 100)
//   var obs_is_min = (Math.round(obs_bg * 100, 2) / 100) == (Math.round(range_bg.min * 100, 2) / 100)
//   var obs_is_max = (Math.round(obs_bg * 100, 2) / 100) == (Math.round(range_bg.max * 100, 2) / 100)
//
//   var likelihood_fn = !min_is_max ?
//     get_likelihood_fn_independent_bg(range_bg, mu, ratio) :
//     undefined;
//
//   var x_val = !min_is_max  & !obs_is_max & !obs_is_min ?
//     transform_beta_ac_to_beta_01(obs_bg, range_bg.min, range_bg.max) :
//     undefined;
//
//   var ll_bg = x_val != undefined ? likelihood_fn.score(x_val) : 0;
//   return(ll_bg)
// }

// generate new probability tables with given parameters //
var sample_independent_table = function(pars_blue, pars_green, pars_bg){
  // var pars_blue = {
  //   alpha: params.alpha_blue, gamma: params.gamma_blue,
  //   shape1: params.shape1_blue, shape2: params.shape2_blue
  // }
  // var pars_green = {
  //   alpha: params.alpha_green, gamma: params.gamma_green,
  //   shape1: params.shape1_green, shape2: params.shape2_green
  // }
  // variance cannot take on arbitrary values, usually must be < mu * (1-mu)
  // var pars_bg = {ratio: params.ratio_range_variance_bg}
  var p_blue = sample_zoib(pars_blue)
  var p_green = sample_zoib(pars_green)
  // display("blue: " + p_blue + " green: " + p_green)

  var range_bg = get_range_bg(p_blue, p_green)
  var diff_ratio = beta({a: pars_bg.shape1, b: pars_bg.shape2}) * (flip(0.5) ? 1 : -1);

  var mu = p_blue * p_green
  var max_add = (range_bg.max - mu)
  var max_sub = mu - range_bg.min

  var delta = diff_ratio < 0 ? diff_ratio * max_sub : diff_ratio * max_add;
  var p_bg = mu + delta;

  // avoid overflow
  // var min_is_max = (Math.round(range_bg.min * 100, 2) / 100) == (Math.round(range_bg.max * 100, 2) / 100)
  // var likelihood_fn_bg = !min_is_max ?
  //   get_likelihood_fn_independent_bg(range_bg, mu, pars_bg.ratio) :
  //   undefined;
  //
  // // if min and max values for P(b,g) are equal, P(b,g) = P(b) = P(g)
  // // otherwise sample from following beta distribution and transform to Y to get
  // // a rv that is beta(shape1, shape2, min_ac, max_ac) distributed !!!
  // // Y~beta(shape1, shape2, min_ac, max_ac) ->
  // // X = (Y-a)/(c-a) ~ beta(shape1, shape2)
  // var p_bg = min_is_max ? range_bg.min :
  //   sample(likelihood_fn_bg) * (range_bg.max - range_bg.min) + range_bg.min;

  // with P(b), P(g) and P(b,g), the probability table is fully defined
  var bng = p_blue - p_bg < 0 ? 0 : p_blue - p_bg; // avoid overflow
  var nbg = p_green - p_bg < 0 ? 0 : p_green - p_bg;
  var nbng = 1 - (p_bg + bng + nbg)

  // display("ac:" + p_bg + " anc: " + anc + " nac: " + nac + " nanc: " + nanc)
  // display("")

  // return(categorical({"vs": ["AC", "A-C", "-AC", "-A-C"],
  //                     "ps": [p_bg, anc, nac, nanc]}))
  return({"AC": p_bg, "A-C": bng, "-AC": nbg, "-A-C": nbng})
}
